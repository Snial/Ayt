/ FIGFORTH PDP8 IN PAL ASSEMBLER
/ THE BIGGEST COMPATIBILITY ISSUE IS THE LACK OF BYTE ACCESS.
/
/ NO ISSUES IN EMIT, KEY, ?TERMINAL, BECAUSE THEY ACCESS I/O.
/
/ MINOR ISSUE IN COUNT, ." ( PAD COULD HOLD LEN AS A WORD. )
/                NFA>LFA. ID., 
/                TYPE, CMOVE ( WE CAN USE HI AND LOW ACCESS - ITS IN A LOOP)
/ FIXABLE        -FIND CREATE
/ NOT SURE       (NUMBER) NUMBER ENCLOSE STRNCMP
/ THE FIELD ADDRESS CONVERSIONS (E.G. NFA) AREN'T PORTABLE. NEED TO FIX THOSE.
/
/ THE APPROACH WILL BE TO USE PAD@ AND PAD!. THE PAD IS HELD AS A STRING UP
/ TO 126 CHARACTERS LONG. 0 PAD@ CONTAINS THE LENGTH IN WORDS. THE LAST CHAR
/ IS 0 IF ITS AN ODD NUMBER OF CHARS IN LENGTH. THUS WE'D HAVE:
/   [0]$0 FOR THE EMPTY STRING [0]X FOR A 1 CHAR STRING [5]HELLO WORLD.
/ WHEN WE GRAB WORDS USING FIND ( OR -FIND) WE NEED TO LEAVE THE REST OF THE
/ STRING IN PAD AS A STRING AND THE WORD AS A STRING TOO. BUT WE DON'T WANT
/ TO USE MUCH EXTRA STORAGE. SO WE HAVE A PREVIOUS WORD WHICH DEFINES THE
/ BEGINNING OF THE WORD'S STRING. THUS AFTER DOING WORD [5]HELLO WORLD WOULD
/ BECOME: [2]HELLO  [2]WORLD. IF IT HAD BEEN [3]HI ALL$0, THEN AFTER CALLING
/ WORD IT WOULD BE [1]HI$0[2] ALL$0. AFTER CALLING WORD AGAIN IT'D BE:
/ [1]ALL    [0]$0. IMPORTANTLY, IT MEANS THAT WE CAN SENSIBLY SUPPORT STRINGS
/ UP TO 126 CHARACTERS, WHICH MEANS WE CAN ACCOMMODATE A WHOLE LINE OF A PROPER
/ FORTH SCREEN. WE CAN STORE STRINGS ANYWHERE IN MEMORY.
/
/ RESOURCES.
/ THE OBJECTIVE FOR FIGFTH PDP8 IS TO FIT IT IN 3KW, WHICH IS 6KB, SO THE
/ MAXIMUM ADDRESS IS 5777. THIS WOULD GIVE US AROUND 2KB FOR USER DEFS.
/ THE IDEAL WOULD BE 2KW, A MAXIMUM ADDRESS OF 3777. AT THE MOMENT (WITH
/ MOST OF THE PRIMITIVES WRITTEN AND A FEW COLON DEFS), WE'VE USED JUST UNDER
/ 1KB, AROUND 1/4 USED.
/ ESTIMATED SIZE: MARK 1 FIGFORTH GOES TO 0X0F40. ASSEMBLER WILL FINISH AT
/ 1123. UDIV WILL BE <100 WORDS. SO TOTAL ASSEMBLER 1223. EST SIZE 4400,
/ LEAVING AROUND 3KB FOR USEFUL CODE. WITH THIS SYSTEM, SAVE AND LOAD WILL
/ BE LIMITED TO DUMPING USER CODE TO TAPE AND READING IT IN.
/
/ IN FIGFTH I ALSO CHANGE THE LINKAGE. THE LFA POINTS TO THE PREVIOUS NFA, SO
/ WE HAVE TO CALCULATE THE LFA AND CFA FROM THAT.
/
/ BASIC WORDS: 1140 (AROUND 1KB)
/ KBD IO     :    0
/ FORTH DEFS : 0145
/
/ CORE VARS:
/ [W], [RP], [SP], [IX], [ILIM], [T0].. [T3], [C63], [QTF]
/ HEADERLESS DEFS:
/ OPDOES, *ENTER, *NEXT, *EXIT, *RESET, *TTINIV,
/ CONSTD, VARD, *HDIV, SADDR, 
/ CORE DEFS:
/ *LIT, *EXEC, BRA, QBRA, LOOP, PLOOP, DO, *UMUL, *UDIV,
/ *BITAND, *BITOR, *BITXOR, LEAVE, *RFROM, *TOR, *OPR, *PLUS
/ *DPLUS, *MINUS, *DMINUS, *SWAP, *EQ0, *LT0, *OVER, *DUPE,
/ *FETCH, *DROP, SFETCH, *PLING, DIV2, SPLING, QTERM,
/ *EMIT, *KEY
/ MID DEFS:
/ MUL2, ONEPL, QDUP, COUNT, LEN0, SLEN, TYP, SPACE,
/ TDUP, SUB, LT, MAX, SPACES, CR, DOTQX
/ ZERO, ONE, TWO, THREE, BLANK, PLUSPL, TOGLE,
/ ONEPLS, TWOPLS, HERE, ALLOT, COMMA, *BUILDS*, CONST,
/ *US_DP*,
/
/ CORE ROUTINE LENGTHS
/ PAGE0:
/ OPDOES: 7 ENTER: 7 NEXT: 5, EXIT: 4
/ PAGE2: 278+236
/ RESET: 8 NEEDS CHANGING.
/ CONSTD: 5 VARD: 5 LIT: 7 EXEC: 10
/ BRA: 9 QBRA: 16 LOOP: 19 PLOOP: 16
/ DO: 24 UMUL: 40 HDIV: 22 UDIV: 18
/ BITAND: 12 BITOR: 14 BITXOR: 15
/ RFROM: 8 TOR: 12 OPR: 6 PLUS: 12
/ DPLUS: 22 MINUS: 6 DMINUS: 15
/ SWAP: 14 EQ0: 9 LT0: 9 OVER: 11
/ DUPE: 5 FETCH: 6 DROP: 8 SADDR: 12
/ SPTR: 11 SFETCH: 10 PLING: 14
/ LENPUT: 14 DIV2: 7 SPLING: 19
/ QTERM: 12 TTYINI: 6 EMIT: 13
/ KEY: 13
/ MID-LEVEL DEFS: 247.
/ MUL2: 6 ONEPL: 6 QDUP: 9 COUNT: 7
/ LEN0: 8 TYPER: 26 TYPE: 9 SPACE: 7
/ TDUP: 7 SUB: 5 OPLT: 5 MAX: 10
/ SPACES: 16 CR: 10 LENW: 5 LEN2W: 3
/ DOTQX: 12 ZERO: 3 ONE: 3 TWO: 3 THREE: 3
/ BLANK: 5 PLUSPL: 10 TOGGLE: 11 ONEPLS: 6
/ TWOPLS: 6 HERE: 7 ALLOT: 7 COMMA: 7
/ BUILDS: 8 CONST: 13 VAR: 7
/ 

FLGSMG=40
FLGIMM=20
FLGST8=FLGIMM
FNDMSK=FLGSMG-1
LK0=0
KEYBS=10

*0

	0	/ INTERRUPT
		/ NO HARDWARE RESET ADDRESS
		
*10		/ AUTOINC VARS.
IP,
	0	/ IP AUTO INCS.
A1,
	0
*40

/ *** BASIC DEFINITIONS APPEAR HERE.
W,
	0
RP,	/ RETURN POINTER PUSHES DOWN
	0
SP,	/ DATA STACK POINTER PUSHES UP
	0
	
PREVLK=.

IX,
	0	/ CACHED
	
ILIM,
	0	/ CACHED

T0,
	0	/ A SECOND TEMP.
T1,
	0
T2,
	0	/ THIRD AND 4TH TEMP!
T3,
	0	/ 5TH TEMP.
C63,
	77	/ ACCESS LOWER BYTE.
QTF,
	0


/ OPDOES IN PDP8 FORTH. DOES> COMPILES A (DOESX) ENTRY INTO A DEFINER'S DEF.
/ EVERY (DOESX) ENTRY IS SPECIFIC TO EACH DEFINER, BECAUSE DEFS NEED TO LINK
/ TO THE ACTUAL DOES CODE FOR THE DEFINER, BUT THEY ALL DO THE SAME THING -
/ PUSH W+1 ONTO THE STACK. THUS DOES ITSELF COMPILES JMS OPDOES INTO THE
/ FORTH INSTRUCTION STREAM AND FOLLOWS IT WITH FORTH.
/ ON ENTRY TO OPDOES, IP POINTS TO THE WORD AFTER THE USAGE OF THE DEFINER'S DEF
/ . W POINTS TO THE PFA FOR THE DEFINER'S DEF. THE RETURN ADDRESS POINTS
/ TO THE NEW FORTH INSTRUCTION STREAM.
/ A SIMPLE EXAMPLE:
/ FORTH:                             COMPILES AS:
/ : ARRAY <BUILDS ALLOT DOES> + ;    HEADER "ARRAY", ENTER, BUILDS, ALLOT,
/                                    DOES, (ARRAY2:) JMS OPDOES, PLUS, EXIT
/ 12 ARRAY MONTHS                    HEADER "MONTHS", ARRAY2, 0... 0
/
/ USAGE                              EXECUTES MONTHS AS:
/ : T1 6 MONTHS @  ;                 IP**@, W**MONTHSCFA, JUMPS TO ARRAY2.
/                                    JMS OPDOES ( THE INSTRUCTION AT ARRAY2)
/                                        PUSHES W+1 (MONTHSPFA) ON DS.
/                                        PUTS OPDOES RETURN (ARRAY2+1) IN W.
/                                        CONTINUES FROM ENTER. SO FORTH TREATS
/                                        IT AS A COLON DEF BEGINNING AT
/                                        ARRAY2+1, THE DOES> PART FOR ARRAY.
OPDOES,	0 / W+1 POINTS TO THE PFA
	TAD W
	IAC
	ISZ SP
	DCA I SP	/ SAVE PFA ON STACK.
	TAD OPDOES	/ RETURN ADDR FROM OPDOES.
	DCA W	/ READY FOR ENTER.

ENTER,
	CLA CMA
	TAD RP
	DCA RP		/DEC RP
	TAD IP
	DCA I RP	/ SAVE IP
	TAD W		/ W POINTED TO THE OLD CFA
	DCA IP		/ IS THE NEW IP
NEXT,
	TAD I IP	/PRE-INC. GET CFA FOR NEXT INS IN ACC.
	DCA W		/ W = CFA.
	TAD I W		/ GET THE MACHINE EXECUTION ADDRESS.
	DCA T0
	JMP I T0	/ IND-THREADED, JUMP TO ADDRESS POINTED TO BY CFA.
EXIT,
__Header EXIT ;S 0 EXIT+1
	TAD I RP	/ GET RETURN IP
	ISZ RP		/ POST INC RP
	DCA IP		/ SAVE RETURN IP
	JMP NEXT	
	/ EXECUTION TIMES: NEXT=12*1.5. ENTER=14*1.5+NEXT. EXIT=8*1.5+NEXT.
	/ THATS 18US FOR NEXT, 55KIPS, ENTER+EXIT=19KIPS.

/ THERE'S ABOUT 60 WORDS OF ZERO PAGE FREE.	
UP,
	0; 0; 0; 0; 0; 0; 0; 0
	0; 0; 0; 0; 0; 0
	/ ROOM FOR 64 CHARS IN TIB.
TIB0,
	0; 0; 0; 0; 0; 0; 0; 0
	0; 0; 0; 0; 0; 0; 0; 0
	0; 0; 0; 0; 0; 0; 0; 0
	0; 0; 0; 0; 0; 0; 0; 0
	

*200

RESET,
	JMS I TTINIV
	TAD COLDH
	DCA IP
WARMV,
	TAD C7577
	DCA RP	/ SETUP RP TO END OF RAM
	TAD C7400
	DCA SP	/ 128 ENTRIES FOR STACKS.
	JMP NEXT
TTINIV,
	TTYINI
COLDH,
	COLDV-1
COLDV,
	COLD
C7577,
	7577
C7400,
	7400

CONSTD,	/ CONST DOES PART. (W+1) IS DATA
	ISZ W		/ MAKE W POINT TO PFA.
	TAD I W		/ GET CONTENTS OF PFA IE THE CONST.
	ISZ SP
	DCA I SP
	JMP NEXT

VARD,	/ VAR DOES PART W+1 IS DATA.
	TAD W
	IAC			/ ACC POINTS TO PFA.
	ISZ SP
	DCA I SP
	JMP NEXT

/ OPLIT
__Header LIT LIT 0 LIT+1
	TAD I IP	/ GET THE LITERAL VALUE FROM IP AND INC IP
	ISZ SP
	DCA I SP	/ STORE IT IN TOS
	JMP NEXT

/ OPEXECUTE EXEC ADDRESS IS IN TOS, POP INTO W.
__Header EXEC EXEC 0 EXEC+1
	TAD I SP
	DCA W
	CLA CMA
	TAD SP
	DCA SP
	JMP ENTER

/ OPBRANCH BRANCH TARGET IS ABSOLUTE.
__Header BRA (BRANCH) 0 BRA+1
	TAD I IP	/ GET THE BRANCH TARGET.
	DCA IP
	JMP NEXT
/ OP0BRANCH POP TOS, IF IT'S 0, BRANCH.
__Header QBRA (0BRANCH) 0 QBRA+1
	TAD I SP
	DCA W
	CLA CMA
	TAD SP
	DCA SP	/ DROP TOS
	TAD I W
	SNA
	JMP BRA+1	/ DO BRANCH IF 0.
QBR4,
	ISZ IP
	JMP NEXT	/ SKIP BRANCH TARGET AND DO NEXT.
	
/ OPLOOP INC IX AND IF < LIM BRANCH
__Header LOOP (LOOP) 0 LOOP+1
	ISZ IX
	NOP
LOOP3,
	TAD ILIM
	CLL CMA IAC	/NEGATE
	TAD IX	/ LINK SET IF REACHED LIMIT
	SNL
	JMP BRA
	/ NEED TO POP J AND JLIM TO IX AND ILIM.
	TAD I RP
	DCA IX
	ISZ RP
	TAD I RP
	DCA ILIM
	ISZ RP
	JMP QBR4	/ SKIP BRANCH.
	
/ PLOOP
__Header PLOOP (+LOOP) 0 PLOOP+1
	TAD I SP
	DCA W
	CMA
	TAD SP
	DCA SP	/ DEC SP TO DROP DATA.
	TAD W
	TAD IX
	DCA IX
	JMP LOOP3	/ REST IS SAME AS LOOP

/ OPDO NOS AND TOS = I AND ILIM.
__Header DO (DO) 0 DO+1
	CLL CLA CMA RAL	/ RP
	TAD RP
	DCA RP		/RP-=2.
	CLA CMA
	TAD RP
	DCA A1
	TAD IX
	DCA I A1
	TAD ILIM
	DCA I A1	/ SAVE OLD I AND ILIM.
	CLL CLA CMA RAL
	TAD SP
	DCA SP
	TAD SP
	DCA A1
	TAD I A1
	DCA ILIM
	TAD I A1
	DCA IX	/ NEW DO LOOP STORED
	JMP NEXT

/ UMUL ( U U -- DL DH )
/ USING AN EARLY OUT ALGORITHM:
/ WHILE B: SUM*=2; IF B&1 SUM+=A; B/=2.
/ T2:T1 = SUM, W=A, T0=B.
/ TIMING=22C*12+32C = 296C, 444US OR 2.25KMULS/S.
__Header UMUL U* 0 UMUL+1

	DCA T1
	DCA T2	/CLEAR SUM
	TAD I SP
	DCA W
	CLL CML CMA
	TAD SP
	DCA SP	/ RESET L TOO.
	TAD I SP
	DCA T0	/ B
UMUL2,
	CLA
	TAD T1
	CLL RAL
	DCA T1
	TAD T2
	RAL
	DCA T2	/ SUM*=2.
	TAD T0
	CLL RAR
	DCA T0
	SNL
	JMP UMUL3
	TAD T1
	TAD W
	DCA T1
	CML RAL	/CARRY WAS INVERTED BECAUSE L HAD BEEN 1.
	TAD T2
	DCA T2
UMUL3,
	TAD T0
	SZA
	JMP UMUL2	/22C*12
	TAD T1
	DCA I SP
	ISZ SP
	TAD T2
	DCA I SP	/ PUSH RESULT BACK ON STACK.
	JMP NEXT

CM12,
	-14			/ -12 IN OCTAL.

HDIV, 0			/ DIVISOR IN W.
	TAD CM12
	DCA T0	/ LOOP.
	CLL CMA	/ MAKE SURE CY STARTS WITH A 1.
	TAD SP
	DCA SP
	TAD I SP	/POP NEXT DIVIDEND INTO T1.
	DCA T1
HDIV1,
	TAD T1
	RAL
	DCA T1
	TAD T2
	RAL				/ GET NEXT BIT FROM DIVIDEND.
	CLL				/ CLEAR CY.
	TAD T3			/ -DIVISOR CARRY=1 IF IT WENT OK.
	SZL
	JMP HDIV2		/ CY=1 SO ACC=NEW T2.
	TAD W			/ +=DIVISOR
	CLL				/ MAKE SURE CY=0.
HDIV2,
	DCA T2			/ UR:UQ*=2+OLD CARRY.
	ISZ T0
	JMP HDIV1
	JMP I HDIV

/ OPDIV ( AL AH B - UR UQ )
/ POPS PARAMS TO TEMPS:
/ REP 12: UR:UQ*=2+OLD CARRY. UR-=DIVISOR. IF CY UR+=DIV
/ TIMING HDIV=18C*12+1.5C*12+16C+2C (JMS) = 242C
/ UDIV=26C+484 = 510C = 765US, 1.3 KDIVS/S
__Header UDIV U/ 0 UDIV+1
	TAD I SP
	DCA W	/ DIVISOR
	TAD W
	CMA IAC
	DCA T3	/ -DIVISOR.
	DCA T2		/ REMAINDER.
	JMS HDIV	/ UPPER.
	JMS HDIV	/ LOWER WORD, ACC=0, SP POINTS TO AL (=UR)
	TAD T2		/ CY UNCHANGED, CONTAINS FINAL UQ BIT.
	DCA I SP	/ SAVED UR
	ISZ SP
	TAD T1
	RAL			/ CY HADN'T CHANGED, GET UQ BIT.
	DCA I SP	/ SAVED UQ
	JMP NEXT

/ OPAND SIMPLE BITWISE AND.
__Header BITAND AND 0 BITAND+1
	TAD I SP	/ GET TOS
	DCA W
	CMA
	TAD SP
	DCA SP
	TAD I SP
	AND W
	DCA I SP
	JMP NEXT
	
/ OPOR = A AND NOT B + B
__Header BITOR OR 0 BITOR+1
	TAD I SP	/ GET TOS
	DCA W		/ A
	CMA
	TAD SP
	DCA SP
	TAD I SP
	CMA			/ NOT B
	AND W		/ A AND NOT B
	TAD I SP	/ A AND NOT B + B
	DCA I SP
	JMP NEXT
	
/ OPXOR = A + B - 2*(A AND B)
__Header BITXOR XOR 0 BITXOR+1
	TAD I SP	/ GET TOS
	DCA W		/ B
	CMA
	TAD SP
	DCA SP
	TAD I SP
	AND W		/ A AND B
	CLL CMA IAC RAL	/ * -2.
	TAD W		/ B - 2*(A AND B)
	TAD I SP	/ A+B - 2*(A AND B)
	DCA I SP
	JMP NEXT

/ OPLEAVE
__Header LEAVE LEAVE 0 LEAVE+1
	TAD ILIM
	DCA IX
	JMP NEXT

/ OPRFROM
__Header RFROM R> 0 RFROM+1
	TAD I RP
	ISZ SP
	DCA I SP
	ISZ RP		/ INC RP TOO (POPPED).
	JMP NEXT	/
/ OPTOR
__Header TOR >R 0 TOR+1
	CLA CMA
	TAD RP
	DCA RP	/ DEC RP.
	TAD I SP
	DCA I RP	/ COPY SP TO RP.
	CLA CMA
	TAD SP
	DCA SP
	JMP NEXT

/ OPR ( ACTUALLY J ON OUR SYSTEM )
__Header OPR J 0 OPR+1
	TAD I RP
	ISZ SP
	DCA I SP
	JMP NEXT	/

/ OPPLUS
__Header PLUS + 0 PLUS+1
	TAD I SP	/ GET TOS
	DCA W
	CMA
	TAD SP
	DCA SP
	TAD I SP
	TAD W
PLUS2,
	DCA I SP
	JMP NEXT

CM4,
	-4
	
/ OPDPLUS ( AL AH BL BH -- SL SH)
__Header DPLUS D+ 0 DPLUS+1
	TAD CM4
	TAD SP
	DCA A1	/ GET READY TO POP 4 PARAMS
	TAD I A1
	DCA W	/ AL
	TAD A1
	DCA SP
	TAD I A1
	DCA T0
	CLL
	TAD I A1	/ BL
	TAD W	/ AL+BL
	DCA I SP / SUMLO
	ISZ SP	/ POINT TO HI.
	RAL		/ CARRY
	TAD I A1	/BH
	TAD T0	/+AH
DPLUS2,
	DCA I SP	/SUM HI
	JMP NEXT

/ OPMINUS ( N -- -N )
__Header MINUS NEG 0 MINUS+1
	TAD I SP	/ GET TOS
	CMA IAC		/ -TOS
	JMP PLUS2	/ SO MINUS IS SLIGHTLY SLOWER.

/ OPDMINUS
__Header DMINUS DNEG 0 DMINUS+1
	CLA CMA
	TAD SP
	DCA SP
	TAD I SP
	CLL CMA IAC	/ GEN CARRY TOO.
	DCA I SP
	ISZ SP
	CML RAL		/ NOT CARRY INTO BIT 0.
	TAD I SP	/ SO IT'S BH IF RES HAD BEEN 0 BH+1 OTHERWISE.
	CMA IAC / SO IT'S -BH IF RES HAD BEEN 0, -BH-1 OTHERWISE.
	JMP DPLUS2	/ RESUME FROM DPLUS (JUST STORE RESULT)

/ OP0EQ
__Header EQ0 0= 0 EQ0+1
	TAD I SP
	SZA
EQ03,
	CLA CMA  	/ WASNT 0 NOW -1
	CMA			/ WAS 0=>-1, -1=>0.
	DCA I SP
	JMP NEXT

/ OP0LT
__Header LT0 0< 0 LT0+1
	TAD I SP
	RAL
	CLA RAL		/ <0 => 1, >=0 => 0
	CMA IAC		/ 1 => -1, 0 => 0.
	DCA I SP
	JMP NEXT

/ OPSWAP
__Header SWAP SWAP 0 SWAP+1
	TAD I SP	/ GET TOS
	DCA T0
	CLA CMA
	TAD SP	/ GET POINTS TOS
	DCA W	/ W POINTS NOS.
	TAD I W / ACC=NOS.
	DCA I SP
	TAD T0
	DCA I W
	JMP NEXT

/ OPOVER
__Header OVER OVER 0 OVER+1
	CLA CMA
	TAD SP	/ GET TOS
	DCA W	/ W POINTS TO NOS.
	TAD I W / ACC=NOS.
OVER2,
	ISZ SP
OVER3,
	DCA I SP
	JMP NEXT

/ OPDUPE                  EQU 39
__Header DUPE DUP 0 DUPE+1
	TAD I SP	/ GET TOS
	JMP OVER2

/ OPFETCH
__Header FETCH @ 0 FETCH+1
	TAD I SP
	DCA W
	TAD I W
	JMP OVER3
	
/ OPDROP
__Header DROP DROP 0 DROP+1
	CLA CMA
	TAD SP
	DCA SP
	JMP NEXT

/ CHARACTER 0 IN A STRING CONTAINS
/ THE LENGTH OF A STRING. THEREFORE THE
/ ADDRESS WE NEED IS SIMPLY THE FIRST CHAR/2+
/ THE BASE ADDRESS AND THE EVEN BYTE IS THE
/ LOWER BYTE.
POPW, 0
	TAD I SP
	DCA W	/ STRING BASE.
	CMA
	TAD SP
	DCA SP	/ DECSP
	JMP I POPW

SINDX,	0
	AND C63
	CLL RAR		/ WORD OFFSET, CARRY=ODD/EVEN.
	TAD W
	DCA W	/ POINTER TO CHAR
	JMP I SINDX
	
SADDR, 0
	JMS POPW
	TAD I W
	JMS SINDX
	JMP I SADDR

/ STERM TERMINATES THE HI BYTE OF A STRING IF
/ THE LENGTH IS EVEN. INTERNAL WORD.
STERM,
	STERM+1
	JMS SADDR	/W=^CHAR, L=0 IF EVEN
	SZL
	JMP NEXT	/ IF ODD, DO NOTHING.
	TAD I W		/ GOT THE WORD
	AND C63		/ MASK OUT TOP
	DCA I W
	JMP NEXT	/ 8 WORDS.

/ SFETCH USED 23 TIMES IN FIGFTH.
/ WE USE OFFSET BASE SFETCH
/ PAD@ IS LITERALLY PAD SFETCH.
__Header SFETCH $@ 0 SFETCH+1
	JMS POPW
	TAD I SP	/ OFFSET
	JMS SINDX
	TAD I W	/ GOT THE CHAR.
	SZL
	BSW		/ ODD BYTE IS UPPER BYTE.
	AND C63
	DCA I SP
	JMP NEXT	/ DONE.

/ OPPLING
__Header PLING ! 0 PLING+1
	TAD I SP
	DCA W
	CLA CMA
	TAD SP
	DCA SP	/ DEC SP.
	TAD I SP
	DCA I W
DROPR,
	CLA CMA
	TAD SP
	DCA SP	/ DEC SP.
	JMP NEXT

C7700,
	7700

__Header LENPUT LEN! 0 LENPUT+1
	TAD I SP
	DCA W
	CLA CMA
	TAD SP
	DCA SP
	TAD I W
	AND C7700	/ CLEAR THE LENGTH
	TAD I SP	/ GET THE LEN
	DCA I W		/ STORE THE LEN
	JMP DROPR

__Header DIV2 2/ 0 DIV2+1
	TAD I SP
	CLL RAR		/ LSR
	DCA I SP
	JMP NEXT

/ OPCPLING USED 10 TIMES IN FIGFTH.
/ WE USE VALUE STR SPLING.
__Header SPLING $! 0 SPLING+1
	JMS SADDR	/ W POINTS TO ADDR
	TAD I SP	/ GOT VALUE L=0 MEANS STORE LOWER BYTE.
	AND C63		/ MASK VALUE INTO RANGE.
	SZL			/ DONT SWAP IF LOWER BYTE
	BSW
	DCA T0
	TAD C63
	SNL
	BSW			/ OTHER HALF MASK IS 7700
	AND I W
	TAD T0
	DCA I W		/ STORE BYTE AT LAST
	CML CMA	/ PRE COMP LINK SO THAT TAD SP RESTORES IT.
	TAD SP
	DCA SP	/ SP POINTS TO VALUE	
	JMP NEXT


	KSF=	6031	/ KEYBOARD SKIP IF FLAG
	KCC=	6032	/ KEYBOARD CLEAR AND READ CHARACTER
	KRS=	6034	/ KEYBOARD READ STATIC
	KRB=	6036	/ KEYBOARD READ AND BEGIN NEXT READ
	TSF=	6041	/ TELEPRINTER SKIP IF FLAG
	TCF=	6042	/ TELEPRINTER CLEAR FLAG
	TPC=	6044	/ TELEPRINTER PRINT CHARACTER
	TLS=	6046	/ TELEPRINTER LOAD AND START

__Header QTERM ?KEY 0 QTERM+1
	IAC
	KSF	
	CLA
	ISZ SP
	DCA QTF
	TAD QTF		/ COPY FOR KEY.
	DCA I SP	/ STORE ?TERMINAL VALUE.
	JMP NEXT

TTYINI,
	0
	CLA
	DCA QTF
	TLS	/OUTPUT NULL
	JMP I TTYINI

C32,
	40
__Header EMIT EMIT 0 EMIT+1
	/ NEED TO CONVERT CHAR.
	/ IN DEC ASCII6 WE JUST ADD 32.
	TAD C32
EMIT8,		/ EMIT A RAW 8-BIT CHARACTER
	TAD I SP
EMIT2,
	TSF		/ AWAIT INPUT READY
	JMP	EMIT2
	TLS		/ WRITE CHARACTER
	CLA CMA
	TAD SP
	DCA SP / POP TOS
	JMP NEXT

__Header KEY KEY 0 KEY+1
/			  RETURNS CHARACTER IN AC
	TAD QTF
	SZA
	JMP KEY3	/ ?TERMINAL SAID THERE WAS A CHAR.
KEY2,
	KSF		/ AWAIT INPUT READY
	JMP	KEY2
KEY3,
	KRB		/ READ CHARACTER
	AND C63	/ MASK INTO RANGE.
KEY4,
	ISZ SP
	DCA I SP	/ STORE CHAR.
	JMP NEXT

__Header GETI I 0 GETI+1
	TAD IX
	JMP KEY4

__Header GETIL  I' 0 GETIL+1
	TAD ILIM
	JMP KEY4

/ *** MID-LEVEL FORTH DEFINITIONS ****


__Colon MUL2 2*
	DUPE; PLUS; EXIT

__Colon ONEPL 1+
	ONE; PLUS; EXIT

__Colon QDUP ?DUP
	DUPE; QBRA; QDUP2; DUPE
QDUP2,
	EXIT

/ COUNT ( STRING -- STRING LEN )
__Colon COUNT COUNT
	ZERO; OVER; SFETCH; EXIT

/ LEN0 ( STR --)
__Colon LEN0 LEN0
	ZERO; SWAP; LENPUT; EXIT

/ TYPER ( STRING END START -- )	
	OVER; OVER
	OPLT; QBRA; TYPER1	/ IF END<START QUIT.
	SWAP; ONEPLS; SWAP; DO
	GETI; OVER; SFETCH; EMIT
	LOOP
	DROP; EXIT
TYPER1,
	DROP; DROP; DROP; EXIT

/ TYPE ( STR LEN --)
__Colon TYP TYPE
	LIT; ONE; TYPER
	EXIT

__Colon SPACE SPACE
	BLANK; EMIT; EXIT

__Colon TDUP 2DUP
	OVER; OVER; EXIT

__Colon SUB -
	MINUS; PLUS; EXIT

__Colon OPLT <
	SUB; LT0; EXIT

__Colon MAX MAX
	TDUP; OPLT; QBRA; MAX1; SWAP
MAX1,
	DROP; EXIT

__Colon SPACES SPACES
	ZERO; MAX; QDUP; QBRA; SPACS2;
	ZERO; DO;
SPACS1,
	SPACE; LOOP; SPACS1
SPACS2,
	EXIT

__Colon CR CR
	LIT; 15; EMIT8
	LIT; 12; EMIT8
	EXIT	/ OCTAL <CR> <LF>

LEN2W,
	ENTER; BRA; LEN2W1
LENW,
	ENTER; COUNT;
LEN2W1,
	DIV2; ONEPLS; EXIT

/ (.") ADVANCE RET POINTER BY RET&63+1
__Colon DOTQX (.")
	OPR; COUNT; TYP
	RFROM; LENW;
	PLUS; TOR; EXIT

__Header ZERO 0 0 CONSTD
	0
	
__Header ONE 1 0 CONSTD
	1

__Header TWO 2 0 CONSTD
	2

__Header THREE 3 0 CONSTD
	3

__Header BLANK BLANK 0 CONSTD
	0	/ IN OCTAL.

__Colon PLUSPL +!
	SWAP; OVER; FETCH; PLUS; SWAP
	PLING; EXIT

__Colon LENGET LEN@
	FETCH; LIT; 77; BITAND; EXIT

__Colon TOGL TOGGLE
	OVER; FETCH; BITXOR; SWAP; PLING
	EXIT

/ SLIGHTLY SHORTER IN ASSEMBLER.
__Colon ONEPLS 1+
	ONE; PLUS; EXIT
					 
__Colon TWOPLS 2+
	TWO; PLUS; EXIT

__Colon HERE HERE
	US_DP; FETCH; EXIT

__Colon ALLOT ALLOT
	US_DP; PLUSPL; EXIT

__Colon COMMA ,
	HERE; PLING; ONE; ALLOT; EXIT

/ DUMMY DEF FOR NOW.
__Colon BUILDS <BUILDS
	CREATE; SMUDGE
	EXIT

__Colon CONST CONST
	LIT; CONSTD;
CONST1,
	BUILDS;
	HERE; ONE; SUB; PLING
	COMMA; EXIT

__Colon VAR VAR
	LIT; VARD; BRA; CONST1
